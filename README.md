# 单表代换辅助工具

本项目是一个使用 Python 和 Tkinter 构建的图形用户界面（GUI）工具，旨在辅助进行单表代换密码的加密、解密以及辅助破译工作。它结合了统计分析方法和启发式搜索算法，以提高破译效率和准确性。

---

## 基本功能介绍

* **加密与解密**：用户可以输入明文（或密文）和26字母的代换密钥，进行单表代换的加密或解密操作。支持随机生成密钥。
* **手动辅助破译**：
    * 对输入的密文进行字母频率分析，并与标准英文频率对比给出替换建议。
    * 用户可以导入完整密钥，或逐个指定、取消密文字母到明文字母的映射。
    * 实时显示部分解密的文本结果，方便用户根据上下文调整密钥。
* **自动辅助破译（多轮模拟退火）**：
    * 用户输入密文，并可选择性地手动锁定一部分已知的密钥映射（例如 `X=e`）。
    * 程序采用模拟退火算法，在用户指定的轮次内，自动搜索最佳的代换密钥。
    * 基于N-gram（单字母到四字母）统计模型和词典匹配（支持按单词长度加权）计算解密文本的适应度分数，以评估其接近自然英文的程度。
    * 界面会显示当前解密任务中找到的“全程最优解”（密钥、分数、解密文本），并高亮显示用户手动锁定的映射部分。
    * 提供日志区域记录算法发现更优解（包括单轮更优和全程更优）的关键时刻。
    * 用户可以清空当前解密任务的结果和日志（手动锁定的映射会保留），方便基于同一组锁定条件进行新的多轮尝试。

---
## 文件结构

```
单表代换辅助工具/
├── main_gui.py               # 主程序和图形用户界面
├── cipher_logic.py         # 加密和解密核心逻辑
├── english_stats.py        # 英文统计数据 (字母频率等)
├── analysis_helpers.py     # 手动破译的辅助函数 (统计分析等)
├── fitness.py              # 适应度函数 (用于评估解密文本质量)
├── auto_solver.py          # 自动破译算法 (模拟退火)
├── english_monograms.txt   # 【数据文件】英文单字母频率 (需用户提供)
├── english_bigrams.txt     # 【数据文件】英文双字母频率 (需用户提供)
├── english_trigrams.txt    # 【数据文件】英文三字母频率 (需用户提供)
├── english_quadgrams.txt   # 【数据文件】英文四字母频率 (需用户提供)
└── common_words.txt        # 【数据文件】常用英文字典 (若缺失，程序会生成一个简单默认版)
```


---
## 各部分代码功能

* **`main_gui.py`**:
    * 构建工具的图形用户界面 (GUI)，包含各个功能选项卡。
    * 处理用户输入，调用后端逻辑模块。
    * 显示加密、解密、分析和破译的结果。
    * 管理多轮自动破译的流程（包括启动、清空任务）和状态更新（包括全程最优解、日志等）。

* **`cipher_logic.py`**:
    * `validate_key(key)`: 验证输入密钥的有效性（26个不同字母）。
    * `encrypt(plaintext, key)`: 实现单表代换加密算法。
    * `decrypt(ciphertext, key)`: 实现单表代换解密算法。

* **`english_stats.py`**:
    * 存储标准的英文字母频率、常见N-gram列表（bigrams, trigrams）等统计数据，供手动分析时参考。

* **`analysis_helpers.py`**:
    * `get_letter_frequencies(text)`: 计算给定文本中各字母的出现频率。
    * `apply_partial_key(ciphertext, partial_key_map)`: 将用户当前指定的部分密钥应用于密文，显示部分解密结果，未解出的字母用 `_` 表示。
    * `generate_frequency_suggestions_data(ciphertext_freq)`: 根据密文的字母频率与标准英文频率对比，生成初步的替换建议。
    * `load_dictionary_for_analysis()`: 加载词典文件，供手动分析时参考。

* **`fitness.py`**:
    * `load_monograms()`, `load_bigrams()`, `load_trigrams()`, `load_quadgrams()`: 从外部文本文件加载N-gram（单字母到四字母）的出现次数数据，并计算其对数概率，用于评估文本的统计特性。
    * `load_dictionary_for_fitness()`: 加载词典文件 (`common_words.txt`)。
    * `get_monogram_score()`, ..., `get_quadgram_score()`: 分别计算输入文本的单字母到四字母N-gram的平均对数概率得分。
    * `get_dictionary_score(text, weighting_scheme)`: 计算文本的词典匹配得分。支持按单词长度进行线性或二次加权，以突出长单词匹配的重要性，并进行归一化处理（0-100范围）。
    * `calculate_fitness(...)`: 核心适应度函数。它综合考虑文本的N-gram得分和词典匹配得分（按预设权重），计算出一个总的适应度分数。此分数用于指导自动破译算法的搜索方向，分数越高（绝对值越小，因N-gram得分为负）表明文本越接近自然的英文。

* **`auto_solver.py`**:
    * `generate_random_key()`: 生成一个随机的、合法的26字母代换密钥。
    * `generate_initial_key_with_locks(user_locked_mappings)`: 根据用户在GUI中预设的锁定映射生成初始密钥，未锁定的部分随机填充，确保密钥的整体合法性。
    * `modify_key_with_locks(current_key_list, locked_plain_char_indices)`: 在保持用户锁定的映射不变的前提下，随机交换两个非锁定字母的映射，以产生邻近解。
    * `solve_simulated_annealing(...)`: 实现模拟退火算法。这是自动破译的核心，它通过迭代地修改密钥、评估适应度，并根据模拟退火的概率接受准则来搜索最佳密钥。

---
## 自动解密的原理

本工具的自动解密功能基于**启发式搜索算法**——**模拟退火 (Simulated Annealing)**，并结合了对英文文本统计特性的分析：

1.  **N-gram 频率分析**：
    * 自然语言（如英文）中，单个字母 (monogram)、字母对 (bigram)、三字母组合 (trigram) 直至四字母组合 (quadgram) 的出现频率遵循一定的统计规律。
    * 本工具使用外部文件（`english_monograms.txt` 至 `english_quadgrams.txt`）存储这些N-gram的出现次数。程序在启动时加载这些数据，并计算每个N-gram的对数概率。一个解密后的文本如果其N-gram分布更接近标准英文，则其N-gram得分会更高（更接近0的负数）。

2.  **词典匹配与单词长度加权**：
    * 有意义的英文文本由大量实际存在的单词构成。
    * 程序使用 `common_words.txt` 词典文件来检查解密文本中有效单词的比例。
    * 为了更好地识别有意义的文本，匹配到的**较长的单词会贡献更高的分数**（支持线性或二次方加权），因为长单词的偶然匹配概率远低于短单词。得分会进行归一化处理。

3.  **适应度函数 (`calculate_fitness`)**：
    * 这是评估一个潜在解密密钥“好坏程度”的数学函数。它接收一个用候选密钥解密出的文本。
    * 通过加权组合该文本的N-gram得分（从单字母到四字母）和词典匹配得分（考虑单词长度加权），计算出一个总的适应度分数。
    * **适应度分数越高（即其绝对值越小，因为N-gram得分主要为负），表明该解密文本在统计上越像自然的、可读的英文。**

4.  **模拟退火算法 (`solve_simulated_annealing`)**：
    * **初始化**: 算法从一个初始密钥开始。如果用户提供了部分锁定的密钥映射，初始密钥将包含这些锁定，其余部分随机生成；否则，完全随机生成。
    * **迭代搜索**:
        * 在每次迭代中，算法对当前密钥进行微小的、随机的改动（`modify_key_with_locks`，仅修改非用户锁定的部分），产生一个新的候选密钥。
        * 使用适应度函数评估这个候选密钥解密出的文本质量。
        * **接受准则 (Metropolis准则)**:
            * 如果候选密钥产生的适应度分数**高于**当前密钥，则接受该候选密钥作为新的当前密钥。
            * 如果候选密钥产生的适应度分数**低于**当前密钥，算法并不会立即抛弃它，而是会以一定的概率接受这个“较差”的解。这个概率与当前的“温度”（一个控制参数）以及分数差的大小相关。在算法初期（温度较高时），接受差解的概率较大，这有助于算法跳出局部最优解，探索更广阔的解空间；随着“温度”根据预设的“降温速率”逐渐降低，接受差解的概率会显著减小，算法逐渐更倾向于只接受更好的解，最终稳定在（理想情况下）一个全局或接近全局最优的解上。
        * 算法会持续追踪在单轮模拟退火运行中找到的具有最高适应度分数的密钥及其对应的解密文本，作为“本轮最佳解”。
    * **多轮运行与全程最优解**：GUI层面控制多次执行完整的模拟退火算法（用户可指定轮次）。每一轮模拟退火独立运行其内部设定的迭代次数。每一轮结束后，其找到的“本轮最佳解”会与一个在当前整个解密任务中（跨所有已完成轮次）持续追踪的“全程最优解”进行比较。如果本轮结果更优，则更新“全程最优解”。这个“全程最优解”会持续显示在界面上，直到用户点击“清空当前任务和日志”按钮。

5.  **用户手动锁定映射**：
    * 用户可以在自动破译开始前，在指定的输入框中预先设定一部分确定的密文到明文的映射（例如 `X=e`）。
    * 模拟退火算法在生成初始密钥和后续迭代修改密钥时，都会严格遵守这些用户锁定的映射，不会改变它们。搜索将在剩余未确定的字母中进行。
    * 最终解密结果会用特定样式（如蓝色粗体）高亮显示用户手动锁定的部分，以区分程序自动找到的部分。

通过这种结合了随机探索和贪心选择的策略，模拟退火算法能够在巨大的密钥空间（26! 种可能性）中进行有效的搜索，逐步逼近最能还原出“合理”英文明文的密钥。

---
## 工具的使用方法

### 依赖

* Python 3.x
* Tkinter (通常是Python标准库的一部分，无需额外安装)

### 数据文件准备

为了使工具（尤其是适应度函数和自动破译功能）能够正常且有效地工作，您需要在程序 (`main_gui.py`) 所在的目录下准备以下**纯文本数据文件**：

1.  **`english_monograms.txt`**: 英文单字母出现次数统计。格式：每行 `字母 次数` (例如 `E 1270211`)。
2.  **`english_bigrams.txt`**: 英文双字母出现次数统计。格式：每行 `双字母 次数` (例如 `TH 35610`)。
3.  **`english_trigrams.txt`**: 英文三字母出现次数统计。格式：每行 `三字母 次数` (例如 `THE 181321`)。
4.  **`english_quadgrams.txt`**: 英文四字母出现次数统计。格式：每行 `四字母 次数` (例如 `TION 13168375`)。
    * **重要提示**: N-gram文件的质量和代表性对破译效果至关重要。数据量越大、越能反映通用英文的统计特性，效果越好。您可以从网络上寻找相关的英文语料库统计数据。
5.  **`common_words.txt`**: 一个包含常用英文单词的文本文件，每行一个单词。程序在加载时会自动转换为大写处理。如果此文件缺失或为空，程序会自动创建一个包含少量基本词汇的默认版本，但这会影响词典匹配的准确度和适应度评估。

如果上述N-gram文件缺失或内容无效，程序启动时会弹出警告，自动破译功能仍可运行，但会使用极简的内置备用统计数据，导致适应度评估不准确，破译成功率显著降低。

### 运行工具

确保所有 `.py` 文件和上述数据文件位于同一目录下。然后通过Python解释器运行 `main_gui.py` 文件：

```bash
python main_gui.py
